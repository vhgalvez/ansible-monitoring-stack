# playbook\04_generate_sealed_secret_inline.yml
# Estas tareas se ejecutan por cada `item` en el loop
---
- name: 🔑 Generar hash htpasswd ({{ item.name }})
  shell: echo "{{ item.pass }}" | htpasswd -i -B -n "{{ item.user }}"
  register: htpasswd_output
  changed_when: false

- name: ➕ Codificar en base64 ({{ item.name }})
  set_fact:
    basic_auth: "{{ htpasswd_output.stdout | b64encode }}"

- name: 📄 Renderizar plantilla del Secret ({{ item.name }})
  template:
    src: "{{ basic_auth_template }}"
    dest: "{{ item.unsealed_path }}"
  vars:
    basic_auth: "{{ basic_auth }}"
    namespace: "{{ monitoring_namespace }}"
    secret_name: "{{ item.secret_name }}"

- name: 🔐 Sellar Secret con kubeseal ({{ item.name }})
  shell: >
    {{ kubeseal_path }} --controller-name sealed-secrets-controller
    --controller-namespace kube-system --format yaml
    < {{ item.unsealed_path }} > {{ item.sealed_path }}
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"

- name: ♻️ Eliminar el archivo no cifrado ({{ item.name }})
  file:
    path: "{{ item.unsealed_path }}"
    state: absent

- name: 🚀 Aplicar Secret sellado al clúster ({{ item.name }})
  command: >
    {{ kubectl_path }} --kubeconfig {{ kubeconfig_path }} apply -f {{ item.sealed_path }}
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"