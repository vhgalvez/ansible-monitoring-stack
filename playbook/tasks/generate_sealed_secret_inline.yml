# playbook\generate_sealed_secret_inline.yml
#   Se ejecuta con las variables:
#   item.*                ← info de cada servicio
#   basic_auth_template   ← plantilla genérica
#   monitoring_namespace  ← namespace destino
#   kubeseal_path, kubeconfig_path, etc. (desde vars/main.yml)

- name: 🔑 Generar hash htpasswd ({{ item.name }})
  shell: echo "{{ item.pass }}" | htpasswd -i -B -n "{{ item.user }}"
  register: htpasswd_output
  changed_when: false

- name: ➕ Codificar resultado en base64 ({{ item.name }})
  set_fact:
    basic_auth: "{{ htpasswd_output.stdout | b64encode }}"

- name: 📄 Renderizar Secret plano ({{ item.name }})
  template:
    src: "{{ basic_auth_template }}"
    dest: "{{ item.unsealed_path }}"
  vars:
    basic_auth: "{{ basic_auth }}"
    namespace: "{{ monitoring_namespace }}"
    secret_name: "{{ item.secret_name }}"

- name: 🔐 Sellar Secret con kubeseal ({{ item.name }})
  shell: >
    {{ kubeseal_path }} --controller-name sealed-secrets-controller
    --controller-namespace kube-system --format yaml
    < {{ item.unsealed_path }} > {{ item.sealed_path }}
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"

- name: ♻  Eliminar archivo plano ({{ item.name }})
  file:
    path: "{{ item.unsealed_path }}"
    state: absent

- name: 🚀 Aplicar Secret sellado al clúster ({{ item.name }})
  command: >
    {{ kubectl_path }} --kubeconfig {{ kubeconfig_path }} apply -f {{ item.sealed_path }}
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"